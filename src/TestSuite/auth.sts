// import { Test, TestingModule } from '@nestjs/testing';
// import { AuthService } from '../services/auth.service';
// import { JwtService } from '@nestjs/jwt';
// import { UserRepository } from '../repositories/user.repository';
// import * as bcrypt from 'bcrypt';
// import { MESSAGES } from '../helpers/constants/errors';
// import { UnauthorizedException } from '@nestjs/common';

// describe('AuthService', () => {
//     let authService: AuthService;
//     let userRepository: Partial<UserRepository>;
//     let jwtService: Partial<JwtService>;

//     beforeEach(async () => {
//         userRepository = {
//             createUser: jest.fn(),
//             findByEmail: jest.fn(),
//         };

//         jwtService = {
//             signAsync: jest.fn(),
//         };

//         const module: TestingModule = await Test.createTestingModule({
//             providers: [
//                 AuthService,
//                 { provide: UserRepository, useValue: userRepository },
//                 { provide: JwtService, useValue: jwtService },
//             ],
//         }).compile();

//         authService = module.get<AuthService>(AuthService);
//     });

//     afterEach(() => jest.clearAllMocks());

//     describe('signup', () => {
//         it('should create a new user and return a Success message', async () => {
//             const username = 'Arjun';
//             const email = 'Arjun169@example.com';
//             const password = 'password';

//             (userRepository.createUser as jest.Mock).mockResolvedValue({
//                 _id: 'user123',
//                 username: username,
//                 email: email,
//             })
//             const result = await authService.signUp(username, email, password)

//             expect(userRepository.createUser).toHaveBeenCalledWith(username, email, password)
//             expect(result).toEqual({ message: MESSAGES.USER_CREATED_SUCCESS })
//         })
//     })
//     describe('signin', () => {
//         it('should throw UnauthorizedException if user is not found', async () => {
//             (userRepository.findByEmail as jest.Mock).mockResolvedValue(null)

//             await expect(authService.signIn('invalid@gmalll.com', 'password'))
//                 .rejects
//                 .toThrow(UnauthorizedException)
//         })

//         it('should throw unauthorizedException if the password is not the same', async () => {
//             const fakeUser = {
//                 id: 'user123',
//                 email: 'username',
//                 password: 'hashpass',
//             };
//             (userRepository.findByEmail as jest.Mock).mockResolvedValue(fakeUser)
//             // jest.spyOn(bcrypt, 'compare').mockResolvedValue(false)

//             await expect(authService.signIn(fakeUser.email, 'Wrongpass'))
//                 .rejects
//                 .toThrow(UnauthorizedException)
//         })
//         it('should return access_token if the given credentials are correct', async () => {
//             const fakeUser = {
//                 _id: 'user123',
//                 email: 'username',
//                 password: 'hashpass',
//             };
//             const expectedtoken = 'jwt-token';

//             (userRepository.findByEmail as jest.Mock).mockResolvedValue(fakeUser);
//             jest.spyOn(bcrypt, 'compare').mockImplementation(async () => true);
//             (jwtService.signAsync as jest.Mock).mockResolvedValue(expectedtoken)

//             const result = await authService.signIn(fakeUser.email, 'correctpass')

//             expect(userRepository.findByEmail).toHaveBeenCalledWith(fakeUser.email)
//             expect(bcrypt.compare).toHaveBeenCalledWith('correctpass', fakeUser.password);
//             expect(jwtService.signAsync).toHaveBeenCalledWith({ email: fakeUser.email, _id: fakeUser._id });
//             expect(result).toEqual({ access_token: expectedtoken });
//         })
//     })
// })